#include "util_windows.h"

#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <iterator>

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#include <windows.h>


namespace amd {

    /// Header for the on-disk format generated by astcenc.
    struct ASTCHeader
    {
        /// Magic value
        uint8_t magic[4];
        /// Block size in X
        uint8_t blockdimX;
        /// Block size in Y
        uint8_t blockdimY;
        /// Block size in Z
        uint8_t blockdimZ;
        /// Size of the image in pixels (X), least significant byte first.
        uint8_t xsize[3];
        /// Size of the image in pixels (Y), least significant byte first.
        uint8_t ysize[3];
        /// Size of the image in pixels (Z), least significant byte first.
        uint8_t zsize[3];
    };
    static_assert(sizeof(ASTCHeader) == 16, "Packed ASTC header struct is not 16 bytes.");

    #define ASTC_MAGIC 0x5CA1AB13

    bool loadASTCTextureFromAsset(
        const char* const pPath, const std::vector<uint8_t>& compressed, std::vector<uint8_t> *pBuffer, unsigned *pWidth, unsigned *pHeight, VkFormat *pFormat
    ) {
        if (compressed.size() < sizeof(ASTCHeader))
            return false;

        ASTCHeader header;
        memcpy(&header, compressed.data(), sizeof(ASTCHeader));
        uint32_t magic = header.magic[0] | (uint32_t(header.magic[1]) << 8) | (uint32_t(header.magic[2]) << 16) |
                        (uint32_t(header.magic[3]) << 24);

        if (magic != ASTC_MAGIC)
        {
            //LOGE("Texture %s is not ASTC.\n", pPath);
            return false;
        }

        if (header.blockdimZ != 1)
        {
            //LOGE("ASTC 3D textures not supported yet in Vulkan.\n");
            return false;
        }

        if (header.blockdimX == 4 && header.blockdimY == 4) // 4x4
            *pFormat = VK_FORMAT_ASTC_4x4_SRGB_BLOCK;
        else if (header.blockdimX == 5 && header.blockdimY == 4) // 5x4
            *pFormat = VK_FORMAT_ASTC_5x4_SRGB_BLOCK;
        else if (header.blockdimX == 5 && header.blockdimY == 5) // 5x5
            *pFormat = VK_FORMAT_ASTC_5x5_SRGB_BLOCK;
        else if (header.blockdimX == 6 && header.blockdimY == 5) // 6x5
            *pFormat = VK_FORMAT_ASTC_6x5_SRGB_BLOCK;
        else if (header.blockdimX == 6 && header.blockdimY == 6) // 6x6
            *pFormat = VK_FORMAT_ASTC_6x6_SRGB_BLOCK;
        else if (header.blockdimX == 8 && header.blockdimY == 5) // 8x5
            *pFormat = VK_FORMAT_ASTC_8x5_SRGB_BLOCK;
        else if (header.blockdimX == 8 && header.blockdimY == 6) // 8x6
            *pFormat = VK_FORMAT_ASTC_8x6_SRGB_BLOCK;
        else if (header.blockdimX == 8 && header.blockdimY == 8) // 8x8
            *pFormat = VK_FORMAT_ASTC_8x8_SRGB_BLOCK;
        else if (header.blockdimX == 10 && header.blockdimY == 5) // 10x5
            *pFormat = VK_FORMAT_ASTC_10x5_SRGB_BLOCK;
        else if (header.blockdimX == 10 && header.blockdimY == 6) // 10x6
            *pFormat = VK_FORMAT_ASTC_10x6_SRGB_BLOCK;
        else if (header.blockdimX == 10 && header.blockdimY == 8) // 10x8
            *pFormat = VK_FORMAT_ASTC_10x8_SRGB_BLOCK;
        else if (header.blockdimX == 10 && header.blockdimY == 10) // 10x10
            *pFormat = VK_FORMAT_ASTC_10x10_SRGB_BLOCK;
        else if (header.blockdimX == 12 && header.blockdimY == 10) // 12x10
            *pFormat = VK_FORMAT_ASTC_12x10_SRGB_BLOCK;
        else if (header.blockdimX == 12 && header.blockdimY == 12) // 12x12
            *pFormat = VK_FORMAT_ASTC_12x12_SRGB_BLOCK;
        else
        {
            //LOGE("Unknown ASTC block size %u x %u.\n", header.blockdimX, header.blockdimY);
            return false;
        }

        pBuffer->clear();
        pBuffer->insert(end(*pBuffer), begin(compressed) + sizeof(ASTCHeader), end(compressed));
        *pWidth = header.xsize[0] | (header.xsize[1] << 8) | (header.xsize[2] << 16);
        *pHeight = header.ysize[0] | (header.ysize[1] << 8) | (header.ysize[2] << 16);
        return true;
    }

}


namespace {

    template <class Container>
    void split2(const std::string& str, Container& cont, const char delim)
    {
        std::stringstream ss(str);
        std::string token;
        while ( std::getline(ss, token, delim) ) {
            cont.push_back(token);
        }
    }

    template <typename _Iter>
    std::string join(const char delim, _Iter begin, const _Iter end) {
        std::string result;

        result += *begin;
        ++begin;

        for ( ; begin != end; ++begin ) {
            result += delim;
            result += *begin;
        }

        return result;
    }

    // https://stackoverflow.com/questions/612097/how-can-i-get-the-list-of-files-in-a-directory-using-c-or-c
    std::vector<std::string> get_all_dir_within_folder(std::string folder)
    {
        std::vector<std::string> names;
        std::string search_path = folder + "/*.*";
        WIN32_FIND_DATA fd;
        HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
        if ( hFind != INVALID_HANDLE_VALUE ) {
            do {
                // read all (real) files in current folder
                // , delete '!' read other 2 default folder . and ..
                if ( (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                    names.push_back(fd.cFileName);
                }
            } while ( ::FindNextFile(hFind, &fd) );
            ::FindClose(hFind);
        }
        return names;
    }

}


namespace dal {

    std::string getCurrentDir(void) {
        char buffer[MAX_PATH];
        GetModuleFileName(NULL, buffer, MAX_PATH);
        const auto pos = std::string{ buffer }.find_last_of("\\/");
        return std::string{ buffer }.substr(0, pos);
    }

    std::string findResPath(void) {
        const auto cd = getCurrentDir();
        std::vector<std::string> splitted;
        split2(cd, splitted, '\\');

        const auto begin = splitted.begin();
        for ( size_t i = 0; i < splitted.size(); ++i ) {
            const auto lvlCount = splitted.size() - i;
            const auto thisPath = join('/', begin, begin + lvlCount);

            for ( const auto& dir : get_all_dir_within_folder(thisPath) ) {
                if ( dir == "resource" ) {
                    return thisPath + "/resource";
                }
            }
        }

        throw std::runtime_error{ "failed to find resource folder." };
    }

}


namespace dal {

    dal::ImageData open_image_stb(const char* const image_path) {
        dal::ImageData result;

        int img_width, img_height, img_channels;
        const auto pixels = stbi_load(
            image_path, &img_width, &img_height, &img_channels, STBI_rgb_alpha
        );

        if (!pixels) {
            throw std::runtime_error("failed to load texture image!");
        }

        result.width = img_width;
        result.height = img_height;
        result.channels = 4;
        result.format = VK_FORMAT_R8G8B8A8_SRGB;

        const auto imageSize = img_width * img_height * 4;
        result.buffer.resize(imageSize);
        memcpy(result.buffer.data(), pixels, static_cast<size_t>(imageSize));
        stbi_image_free(pixels);

        return result;
    }

    dal::ImageData open_image_astc(const char* const image_path) {
        dal::ImageData result;

        std::ifstream input(image_path, std::ios::binary);
        std::vector<unsigned char> buffer(std::istreambuf_iterator<char>(input), {});

        unsigned int width, height;
        VkFormat format;
        if (!amd::loadASTCTextureFromAsset(image_path, buffer, &result.buffer, &width, &height, &format)) {
            throw std::runtime_error{"failed to decompress ASTC file"};
        }

        result.width = width;
        result.height = height;
        result.format = format;

        return result;
    }

}
